import heapq
from math import inf, sqrt
import random
from queue import PriorityQueue

sqrtof2 = sqrt(2)

"""
A* algorithm to find path between the two given coordinates in the given map 
"""
def initDistance(map_, start):
    """
    Initialize all the distance of the other nodes from the start node
    :param map_: Your map
    :param start: Coordinate of start node in tuple
    :return: A dictionary which record all the distances
    """
    distance = {start : 0}
    for row in range(len(map_)):
        for column in range(len(map_[row])):
            if (row, column) != start:
                distance[(row, column)] = inf
    return distance

def NoBlocked(map_, node) -> bool:
    """
    Check whether the given coordinate is blocked
    :param map_: Your map
    :param node: Your node wish to be checked
    :return: True if not blocked else False
    """
    if map_[node[0]][node[1]]:
        return True
    return False

def inMap(map_, node):
    """
    Ensure the given node is not out of the map
    :param map_: Your map
    :param node: Your node
    :return: True if node is in the map else False
    """
    if 0 <= node[0] < len(map_) and 0 <= node[1] < len(map_[0]):
        return True
    return False

def CalculateHeuristic(node, des, type:str="sld"):
    """
    Calculate the value of Heuristic function for A*
    :param node: The coordinate of start node in tuple
    :param des: The coordinate of destination node in tuple
    :param type: Type of heuristic function :
                 "Euclidean Distance", "Manhattan Distance", "Chebyshev Distance", "Diagonal Distance"
    :return: Value of heuristic
    """
    if type == "sld":
        return sqrt(
        ((node[0] - des[0]) ** 2) + ((node[1] - des[1]) ** 2)
    )

    elif type == "mht":
        return abs(node[0] - des[0]) + abs(node[1] -des[1])

    elif type == "che":
        return max(abs(node[0] - des[0]), abs(node[1] - des[1]))

    elif type == "dia":
        dx = abs(node[0] - des[0])
        dy = abs(node[1] - des[1])
        return (dx + dy) + ((sqrtof2 - 2) * min(dx, dy))

    elif type == "0":
        return 0

def Action(map_, node, des, h="euc", direction=None):
    """
    Return children or the states generated by given node
    :param map_: Your map
    :param node: The parent node
    :param des: The destination node
    :param h: The heuristic function you want:
              "sld", "mht", "che", "dia"
    :param direction: The directions which the node can move:
                      "up", "down", "left", "right",
                      "left-up", "left-down", "right-up", "right-down"
    :return: The dictionary contain coordinate of children as key while heuristic value as value
    """
    children = {}
    actions = {"up": (node[0] - 1, node[1]),
               "down": (node[0] + 1, node[1]),
               "right": (node[0], node[1] + 1),
               "left": (node[0], node[1] - 1), }
    if direction == 8:
        actions.update({
            "left down": (node[0] + 1, node[1] - 1),
            "left up": (node[0] - 1, node[1] - 1),
            "right up": (node[0] - 1, node[1] + 1),
            "right down": (node[0] + 1, node[1] + 1)
        })
    for action in actions:
        if inMap(map_, actions[action]):
            if NoBlocked(map_, actions[action]):
                child = actions[action]
                heu = CalculateHeuristic(child, des, h)
                children[child] = heu
    return children

def AStar(map_, start, des, h="sld", d=8):
    """
    A* Algorithm
    :param map_: Your map
    :param start: The starting coordinate in tuple
    :param des: The destination coordinate in tuple
    :param h: Type of heuristic :"Euclidean Distance", "Manhattan Distance", "Chebyshev Distance", "Diagonal Distance"
    :param d: The directions which the node can move:
                "up", "down", "left", "right",
                "left-up", "left-down", "right-up", "right-down"
    :return: The path from start coordinate to destination coordinate
    """
    prQueue = PriorityQueue()
    prQueue.put((0, start))
    cnt = 0
    parent = {start: None}
    distance = initDistance(map_, start)

    explored = []
    prev_cost = {start : 0}
    while not prQueue.empty():
        ele = prQueue.get()
        dist, node = ele[0], ele[1]

        if node == des:
            break
        children = Action(map_, (node[0], node[1]), des, h, d)
        for child in children:
            if child not in explored:
                heu = children[child]
                prev = prev_cost[node]
                cost = map_[node[0]][node[1]]
                if heu + prev + cost < distance[child]:
                    prQueue.put((heu + prev + cost, child))
                    parent[child] = node
                    distance[child] = heu + cost + prev
                    prev_cost[child] = cost + prev
                explored.append(child)


    print("Current Heuristic : ", h)
    print("Cnt : ", cnt)
    if h != "0":
        if prQueue.empty():
            print("No route founded !")
            return None

    total_distance = prev_cost[des]
    route = []
    while des is not None:
        route.insert(0, des)
        prev = des
        des = parent[des]
    route_str = ""
    for node in range(len(route) - 1):
        route_str += f"{route[node]} -> "
    route_str += f"{route[-1]}"
    print(route_str)
    print(total_distance)
    print(route, explored, total_distance, len(explored))
    return route, explored, total_distance, len(explored)

def RandomMapGenerator(row, column):
    map_ = []
    for i in range(row):
        temp = []
        for j in range(column):
            temp.append(random.randint(0, 1))
        map_.append(temp)

    return map_

if __name__ == "__main__":
    # Test the code using random map generator
    pass
